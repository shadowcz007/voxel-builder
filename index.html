<!--
    Aug 2019
    https://github.com/nimadez/voxel-builder

    MIT License

    Copyright (c) 2019 Nima Dez. (@nimadez)

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

    -------------------------------------------------------------------------------------------
    
    1. Engine/RenderLoop        initialize engine and start render loop
    2. Main Scene               initialize main scene
    3. Axis-View Scene          initialize axis-view scene
    4. Materials                initialize and setup defaultMaterial
    5. Voxels                   create and manipulate voxels(SPS.mesh), store voxel positions and colors
    6. Overlays & Helpers       create, clone and dispose guides
    7. Tools                    camera, add (+symm), remove (+symm), transform (+symm), hide, paint (+symm), pickcolor, fillcolor, hidecolor
    8. Interactions             handle mouse down, mouse move, mouse up (+touch)
    9. HDR & Rendering          create and dispose environment HDR, toggle high-quality rendering pipeline
    10. Files                   new, load (.vox), save (.vox), import voxelized (.obj) and export (.glb)     
    11. Storage & Memory        storage for quick save and restore, save and load memory steps
    12. Create                  create grid and plane
    13. Events                  the events core
    14. Functions               standalone functions
    15. Utilities: babylon      babylon related utils
    16. Utilities: html         html related utils
    17. Help & Tooltips         show help, instructions, tooltips
    18. Startup                 load startup project
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="mobile-web-app-capable" content="yes"> <!-- to launch the page fullscreen when the user has added it to the home screen -->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="A voxel-based modeling application built using Babylon.js engine, optimized for maximum performance and minimum dependencies">
    <meta name="author" content="@nimadez">
    <title>Voxel Builder</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAACgBJREFUeF7lW31QVNcV/70FFiHs8qVREBAQEBQqRPyIdtJE0mRI7HSqjlM1TeuitanptKOZaTNxJtM2Np1OZKZpbP5Q1k6TSsdpOu3Ulsk0UNuIaRIskAShxsLyuYh8L/LNvs558LbvvX3f+5AmuX/unnfvub977u+ee865DD7jjbkb8x85h4QwoIi1IY9lkcECSQwQBwZR3PgsJlhgmAG8DIM2xo/mOaA+9jAGF1u/RQPA58ZOlsXjAEoAbJROZHLGhjeaknHVk4ivb+pAccoQbBJtGKCRBaoZBn92uFCzGGBYCsDwWWQwDMoYwAUGSXIKT8/ZcKUtEb+6lobu0WUBka2pQzhU3IGsxDEw8lp5WRZulkVF3BG0WQWGJQD43FjPAifAwqWkmJ8FPuiN5Sb+odcpKxZuY1G67hb2b+zCSseU8hwZuJlwvOR4Es2hAhESAOxFRPl8eAHAcSVFWBbwDEfj/PtpqG1P1KWvPcyP/YVd+PL6XsQum1H7ptzhwElmHyZ0dSwjZBoAXwX2+FmUMwzSlAbvH7ejsj4Fl1pWYdZvfKiE6Gm4ijuwc+1tRIb7ZYdhWXTYGBx3lOENMyAY1wrAaAVOq606T3Cv/ysVtOdDbaudk3h6e6ssUQr6LneW4YTRsQwBMPxLxNsi8RsApUoEV3NzOSrq1mBw3G5UF035gqRRPLW1DTnLFYmyyj+Fg3HfxpBmZwsCugEghrfZ8BcAudLOieDquuJx9r10tA5G6x3blBwR5fY1g/jmFg+SnJNyfbT4/XhM70mhCwClyRPB3RyIwfm6NLzbGW9qQmY/IqLcm9+D3QU9iI8KIkrdIGgCsGD2V6Urf8sXicrGFFT9e6UpgjM7cel3RJRfK+rEI9l9WBYhIsoW/xS2a20HTQBGKzizD+z5O9Nh+MP1JFhFcFYBQUR57P5WFKcOI4xh+W6rnGV4TG0MVQCEbD81a0PNf1bAXZe2KARnFRBElEe3eLBuhY93rVVPB0UA6Jxngd/xBPfK1UyR62qVwovVz441A3hq2zxRMsBeJT9BFgDy8EZH0UJOzqcBAHKWnE7kynmMsgDIOTqf4C3AG5nsVggCwPdr5LEzuK5kmiOTEfjj9VWobEixxMuzagsQCR7d1obNKcOgI1KuMQw2OFziuQUBMOpGhdqtju/YO7oMr9WnovrmiiU/BvcV9OBLeV7pMRiMAQO304Uy4R8iABYcnla9q0KO0I3+GM4DrO+J1fsZyJtLi5sQrdTwZDh6ff+LD2h1Rqu8K68XBwq75Bwhxc/9fmQKvUQRACPn8ALD4LmP+2PQd8euak7CEfQQJe/C7i3o5nz5iLDAWR3oyjcVjve74lDZkKrqUgsZXgso+p+27RVPAh7IGECMffZU7GGc5L8TATB6Dj0UyWn0xuL4pXzInKmq49HNT+4yRNGeY/e3Idk5oRTtEfU7xzKo64zDz2vX4tZYZOA/HZchUT9C4l4ZM4VTjzZTfMHrLENyEAALMbxq+oMHgBcygzgR5cUPVuOJok7szvcqEpMaohRPeLl2LTyD0ZoEp2WReff6eABoEUr4GGPAAoRHnxQA6pxMeFduL564r1P3nhubCkeUfU7omuqxWJEMxRYoRqgUEBEK85z06rsZQWE3IQAAAkdiAABfBRrYheitHAD8QEQ+BMKeDT3arGt4uuY/oFPp1X+mK4bdJAA0OstQSKNxAFDcnmEwwA+vBgAvc2/MFL6xqQMPre03bN60UgMTdnQNR4H2e3TEHNITxhEVPmcYgaGJCFxoSMGl5lWqfokEALAsEinvwAEwdg4lfgZvGQGAl6WOD23qQNHq4aC4vtxsiNTOXM0IWinesuiOr8fcaWv8qTkJFz9M1nU5kwJgY/FwzGFUcwD43HiaZfELMwDw3+iI66N9KBo/ql4Hz5By1IjC4se2tylag1JeQct0pAAwDL7jcOEVDgCp769nC8gNSER5oKgTBwu7ONIUNjqSXvpHFnel1mrPPHCTyw9IG50KP7ucjWvdcVpdBP0vBYAnwnkOqMAFBtgfigXw3351YxeObGkPUqDplgPfr9qAiZkwTeWLkkfw/MMtcETOimTJoXnuzTw09zk0+5AKBHEAUBlbhgO8BYiiPmYtgAYlh2d3fk+Qgr//KBln3snQpXhc1Ax+WtqE7MQ7InkC78XLOaj1JOjqRygkYwFctGgeADf+BhYPWmEBSuZ79r01+G1jim7Fy3d9hI1JI6a3kZYFgMFlpwsPWQ6Aa3M7xwHSZoUFkGNFJGoJB4gAkAQ+Q9kC+z7XzcXspRleKzhgeCICz765Hjdux+i2JF5QdQtYSYI70gfx7IM3EBUhdmqsOAU+HrgHP6jaAALCaNMiQVGuLxQLWB49jRdLryMzQUxgpHCofgBdsOhyZKapHoNWOEJCpVzF7VygQq7QwawnSLGCH76VayjwonYKiByhUFxhudVIjx/Hjx9pRrJ87o78cMN3gb+3LcdPanJMh99UXWEzlyEtM/xidh+++/lWUxccad/kOj//11x0jczXVJlpqpchzheoQANfzBQKBwiVe/K+Tu7qLEhVGdZ9YNyOUzU5XJAmlCYKiACNDuF1eAGAABFaBQDdB8o2t2NPQY8pEIjty69kmfL8NBwhmYDIfFmbbEgsFOTp2y9k9ONb2zygGIKexhVUeWNR/naWZek4zZAYZwWSoKgeZfXK0H3/K/lePJ7biyTHpGzsYGaOQVOfExcbV1tebxAAIHLG6zwsExSlifBhcau2gBI4cvcFI46SXtDljkFn5IxyWJxPjHyaAXDYZ5QTI9w2cKOisSfWRXmBxWpLZQEnd964kPO9yYPCeQUnR91Yf3vM3vRybabuwkajQN1tAIh/6EjekT5UmH/iTqMqAPyRyLI4Tnk/uRi70QlL5e8WAJJchr70OCkrLJDg01Rn3rGuQuRuAEDZrKNb27l0HGCwQIK+4Etk+NWzskBiMQGQy2caLpHhJy1XKWJFgcRiAKBSIGGuSEoAgihgyv8eSp2glQCo1AmSqqGVyVEPSoWSHFeYrBS1AgCNSlFSz5pCSQ4ElTph+p989/ruOJy/lqYrZh8KAMTsJVm3uepQhVphbvIRNpRGHYJH68TSrBTlO9ACgeT0pq3MAqAn/catvNXF0gEQNMrleTn+vQBdasamw4MWwSgAmQnjOLLFo/VegNvzi1YuL5yF1oMJXlYpda0XAIMp+MV/MCEEQc+TGV5eWrygBYCRIowleTLDT0zPo6mA7EJJHbnWj2b3BWV/ydE6/XYWHPZZI2U4S/doSmQNVF06i2f0FFjSiUFJznvs4sQJudzTs7aghIosi9OzOeC0tOpTi/Hl/td9CujpXM/DST39yMqw8LL4P304Kacw/3SWAUr44isTk6er6yfn6azSBD+Tj6dNrPaSfPJfrjqsjFtcENsAAAAASUVORK5CYII=">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/gh/BabylonJS/Babylon.js@master/dist/babylon.js"></script>                                    <!-- <script src="https://cdn.babylonjs.com/babylon.js"></script> -->
    <script src="https://cdn.jsdelivr.net/gh/BabylonJS/Babylon.js@master/dist/materialsLibrary/babylonjs.materials.min.js"></script>   <!-- <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script> -->
    <script src="https://cdn.jsdelivr.net/gh/BabylonJS/Babylon.js@master/dist/loaders/babylonjs.loaders.min.js"></script>              <!-- <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script> -->
    <script src="https://cdn.jsdelivr.net/gh/BabylonJS/Babylon.js@master/dist/serializers/babylonjs.serializers.min.js"></script>      <!-- <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script> -->
    <style>
        * { margin: 0; padding: 0; }
        html, body { overscroll-behavior-y: contain; user-select: none; overflow: hidden; touch-action: pan-x; } /* prevent pull-down refresh and text selection on chrome mobile */
        body { background: black; font-family: sans-serif; font-size: 11px; color: #cccccc; cursor: default; }
        a { color: slategray; text-decoration: none; }
        a:hover { color: orange; text-decoration: none; }
        canvas { z-index: 0; position: absolute; width: 100%; height: 100%; outline: none; background: radial-gradient(circle, rgb(81, 90, 109) 0%, rgb(49, 53, 68) 100%); }
        ul { background: #5f62702f; position: absolute; list-style-type: none; }
        ul li { background: #242b35; border: 1px solid #161a2096; border-radius: 5px; padding: 3px; text-align: center; }
        ul li:hover, ul li.select, ul li.toggle { background: orange; color: #222; cursor: pointer; }
        ul li.separator { background: none; height: 3px; padding: 0; cursor: default; border: none; }
        ul li.spacer { background: none; height: 3px; padding: 0; cursor: default; border: none; }
        input[type=color] { width: 20px; height: 18px; border: none; background: #2e35414d; outline: none; border: none; border-radius: 50%; vertical-align: text-bottom; }
        input[type=color]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type=color]::-webkit-color-swatch { border: none; border-radius: 20%; }
        input[type=color]:hover { background: white; cursor: pointer; }
        input[type=number] { width: 50px; margin-bottom: 1px; background: #2a313db7; color: #808fa3; padding: 2px; font-size: 11px; text-indent: 5px; border: solid 1px #343c49; border-radius: 3px; text-align: left; outline: none; }
        input[type=number]:hover { color: orange; border: solid 1px #43495a; }
        input[type=checkbox] { display: none; }
        input[type=checkbox] + .material-icons::after { content:"check_box_outline_blank"; color: #475364; }
        input[type=checkbox]:checked + .material-icons::after { content:"check_box"; color: orange; }
        button { width: 115px; background-color: #353f4d; color: #bbb; box-shadow: inset 1px 1px 1px #3f4a58, inset -1px -1px 1px #2f3742; border-radius: 4px; padding: 3px; font-size: 11px; border: 1px solid #161a20bd; outline: none; }
        button:hover { background-color: orange; color: #222; cursor: pointer; }
        label { color: #5c6c81; margin-right: 2px; margin-left: 2px; }
        #menuH_L { background: none; left: 5px; top: 5px; }
        #menuH_L li { display: inline-block; width: 30px; padding: 1px; box-shadow: inset 1px 1px 1px #323b47, inset -1px -1px 1px #29303a; }
        #menuH_R { z-index: 500; background: none; right: 5px; top: 5px; }
        #menuH_R li { display: inline-block; width: 30px; padding: 1px; box-shadow: inset 1px 1px 1px #323b47, inset -1px -1px 1px #29303a; }
        #menuH_C { z-index: 500; background: none; width: 300px; left: 50%; margin-left: -150px; top: 8px; text-align: center; }
        #menuH_C li { display: inline-block; width: 20px; padding: 1px; box-shadow: inset 1px 1px 1px #323b47, inset -1px -1px 1px #29303a; }
        #menuH_C li.selected { background-color: orange; color: #222; }
        #menuV { z-index: 1000; position: fixed; top: 0; right: 0; background: #222731f8; padding: 10px; width: 120px; height: 100%; transform: translate(200px, 0); transition: -webkit-transform 0.2s ease; overflow-y: scroll; }
        #menuV li { background: none; text-align: left; border: none; padding: 0; color: #67778d; }
        #menuV li:hover { background: none; color: orange; }
        #menuV .category { color: #464c5e; background: #1e222b; border: solid 1px #181c22; font-size: 10px; font-weight: bold; text-align: center; margin: 6px 4px 6px 0; padding: 2px; }
        #menuV .category:hover { color: #43495a; background: #1e222b; cursor: default; }
        #toolbar_R { z-index: 500; position: absolute; width: 28px; right: 5px; top: 60px; padding: 3px; border-radius: 5px; }
        #toolbar_R li { margin-bottom: 2px; box-shadow: inset 1px 1px 1px #323b47, inset -1px -1px 1px #29303a; }
        #toolbar_R li.separator { height: 1px; background: #525861; margin-top: 4px; margin-bottom: 4px; box-shadow: none; }
        #toolbar_L { z-index: 500; position: absolute; width: 28px; left: 5px; top: 60px; padding: 3px; border-radius: 5px; }
        #toolbar_L li { margin-bottom: 2px; box-shadow: inset 1px 1px 1px #323b47, inset -1px -1px 1px #29303a; }
        #toolbar_L li.separator { height: 1px; background: #525861; margin-top: 4px; margin-bottom: 4px; box-shadow: none; }
        #color_palette { z-index: 500; position: absolute; left: 5px; top: 252px; padding: 3px; border-radius: 5px; }
        #color_palette li { width: 20px; height: 5px; margin-bottom: 1px; }
        #color_palette li:hover { border: solid 1px orange; }
        #hover { z-index: 1; position: absolute; background: none; left: 60%; top: 20%; }
        #hover li { box-shadow: inset 1px 1px 1px #37414e, inset -1px -1px 1px #2f3742; }
        #hover li:nth-child(1) { cursor: move; }
        #hover li:nth-child(2) { position: absolute; top: -110%; left: 0%; }
        #hover li:nth-child(3) { position: absolute; top: 0%; left: 108%; }
        #hover li:nth-child(4) { position: absolute; top: 0%; left: -108%; }
        #hover li:nth-child(5) { position: absolute; top: 108%; left: 0%; }
        #hover select { appearance: none; width: 18px; background-color: #2a313db7; color: #bbb; font-size: 14px; font-weight: bold; padding: 0; border: none; outline: none; }
        #hover select:hover { color: orange; cursor: pointer; }
        #hover option { font-size: 14px; font-weight: bold; color: #bbb; background-color: #252931; }
        #axisview { background: #161a203f; bottom: 5px; right: 5px; width: 68px; height: 68px; border: 1px solid #161a2096; border-radius: 50%; box-shadow: inset 1px 1px 1px #38404d, inset -1px -1px 1px #38404d; }
        #axisview li { border-radius: 50%; padding: 3px; color: #495363; border: 1px solid #161a2096; }
        #axisview li:nth-child(1) { position: absolute; top: -28%; right: 0%; }
        #axisview li:nth-child(2) { position: absolute; top: -36%; right: 44%; }
        #axisview li:nth-child(3) { position: absolute; top: -18%; right: 83%; }
        #axisview li:nth-child(4) { position: absolute; top: 22%; right: 103%; }
        #axisview li:nth-child(5) { position: absolute; top: 65%; right: 97%; }
        #symmetryaxis { z-index: 500; position: absolute; width: 200px; left: 50%; top: 30px; margin-left: -100px; }
        #symmetryaxis ul { width: 100%; text-align: center; background: none; }
        #symmetryaxis li { width: 10px; height: 11px; background: none; border: none; font-size: 10px; font-weight: bold; padding: 2px 5px 2px 5px; border-radius: 50%; display: inline-block; }
        #symmetryaxis li.selected { background: #eeeeee20; }
        #notifier { opacity: 0; transition: opacity 0.5s; position: absolute; width: fit-content; left: 50%; top: 50%; margin-left: -200px; margin-top: -20px; padding: 3px 5px 3px 5px; background: orange; color: #111; border: dashed 1px #d18800; font-size: 10px; font-weight: bold; text-align: center; border-radius: 5px; }
        #notifier.fade { opacity: 1; }
        #status { color: #ffffff30; position: absolute; bottom: 4px; left: 5px; font-size: 10px; font-weight: bold; opacity: 0.8; }
        #status span { color: #eee; padding: 0 1px 0 1px; }
        #status i { color: #aaa; }
        #help { z-index: 600; background: #21262e; padding: 8px; border-radius: 5px; position: absolute; width: 300px; height: auto; left: 50%; bottom: 5px; margin-left: -160px; transition: 0.5s; overflow: hidden; cursor: help; }
        #help .tip { color: #bbb; font-size: 12px; line-height: 1.3em; }
        #help .tip b { color: orange; }
        #helpbtn { display: none; color: #b4cadb; width: 20px; height: 20px; text-align: center; text-shadow: 1px 1px #000; position: absolute; left: 50%; bottom: 10px; margin-left: -10px; }
        #helpbtn button { width: 30px; }
        #babylonjsLoadingDiv { z-index: 2000; } /* injecting babylon.js css */
        .tooltip { display: none; }
        .material-icons { font-size: 18px; pointer-events: none; vertical-align: middle; text-align: center; }
        ::-webkit-scrollbar { display: none; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <canvas></canvas>
    <ul id="menuH_L">
        <li title="High Quality Render" onclick="toggleHighQuality(); toggleButton(this)"><i class="material-icons">camera</i><i class="tooltip"><b>High Quality Render</b><br>Toggle high-quality render mode, Try loading HDR map for better look and more realistic shading.<br>(warning: not optimized for mobile devices)</i></li>
    </ul>
    <ul id="menuH_R">
        <li title="Main Menu [space]" onclick="toggleVerticalMenu()"><i class="material-icons">menu</i><i class="tooltip"><b>Main Menu</b><br>Open menu to access files, views and user preferences<br>Shortcut [space]</i></li>
    </ul>
    <ul id="menuH_C">
        <li onclick="loadMemory(0)" class="selected">0</li>
        <li onclick="loadMemory(1)">1</li>
        <li onclick="loadMemory(2)">2</li>
        <li onclick="loadMemory(3)">3</li>
        <li onclick="loadMemory(4)">4</li>
        <li onclick="loadMemory(5)">5</li>
        <li onclick="loadMemory(6)">6</li>
        <li onclick="loadMemory(7)">7</li>
        <li onclick="loadMemory(8)">8</li>
        <li onclick="loadMemory(9)">9</li>
        <i class="tooltip"><b>Memory Steps</b><br>Record 10 steps in local memory, click on each step to revert changes, memory cleared on loading new model<br>Shortcuts: [CTRL+Z] Previous, [CTRL+X] Next</i>
    </ul>
    <ul id="menuV">
        <li onclick="toggleVerticalMenu()"><i class="material-icons">exit_to_app</i></li>
        <li class="category">FILE</li>
        <li title="New Project"><button onclick="newProject()">New</button><i class="tooltip"><b>New Project</b><br>Reset scene and load a new project<br>Shortcut: [none]</i></li>
        <li title="Load Project"><button onclick="document.getElementById('openfile_vox').click()">Load</button><i class="tooltip"><b>Load Project</b><br>Reset scene and load project from a file<br>Shortcut: [none]</i></li>
        <li title="Save Project"><button onclick="saveProject()">Save</button><i class="tooltip"><b>Save Project</b><br>Save project to file, user-perferences not included<br>Shortcut: [none]</i></li>
        <li title="Import OBJ"><button onclick="document.getElementById('openfile_obj').click()">Import <span style="color: tomato; font-size: 10px;">[beta]</span></button><i class="tooltip"><b>Import OBJ</b><br>Import model, merge and voxelize meshes.<br>Use "Import Scale" to change voxelization quality, higher scale capture more details.<br>Shortcut: [none]</i></li>
        <li title="Export GLB"><button onclick="exportMesh()">Export</button><i class="tooltip"><b>Export GLB</b><br>Export model to GLB, include colors and grid texture, try Blender to import GLB<br>Shortcut: [none]</i></li>
        <li class="spacer"></li>
        <li title="Higher scale capture more details"><label>Import Scale &nbsp;<input id="user-input-voxelization-scale" type="number" value="30" min="1" max="40" style="width: 38px"></label></li>
        <li class="category">HDRI</li>
        <li title="Load Environment"><button onclick="document.getElementById('openfile_hdr').click()">Load</button><i class="tooltip"><b>Load Environment</b><br>Load HDRI map for lighting and background<br>Shortcut: [none]</i></li>
        <li title="Remove Environment"><button onclick="removeHDR()">Remove</button><i class="tooltip"><b>Remove Environment</b><br>Unload and remove HDRI map<br>Shortcut: [none]</i></li>
        <li class="spacer"></li>
        <li title="Show Skybox" onclick="toggleSkybox()"><input type="checkbox" id="check_skybox"><i class="material-icons"></i> Background <i class="tooltip"><b>Show Skybox</b><br>Toggle skybox/background visibility<br>Shortcut: [none]</i></li>
        <li class="category">CREATE</li>
        <li>
            <label>X&nbsp;</label><input id="user-input-create-x" type="number" value="5" min="1" max="40"><label><40</label><br>
            <label>Y&nbsp;</label><input id="user-input-create-y" type="number" value="6" min="1" max="40"><label><40</label><br>
            <label>Z&nbsp;</label><input id="user-input-create-z" type="number" value="5" min="1" max="40"><label><40</label><br>
            <li class="spacer"></li>
            <button title="Create Grid or Plane" onclick="createGrid()">Grid / Plane<i class="tooltip"><b>Create Grid</b><br>Create grid or plane, use X/Y/Z to define number of voxels, set Y to 1 to create a plane<br>Shortcut: [none]</i></button>
        </li>
        <li class="category">VIEW</li>
        <li title="Toggle Fullscreen [F]" onclick="toggleFullscreen()"><input type="checkbox" id="check_fullscreen"><i class="material-icons"></i> Fullscreen <i class="tooltip"><b>Toggle Fullscreen</b><br>Enable/disable fullscreen<br>Shortcut: [F]</i></li>
        <li class="spacer"></li>
        <li title="Toggle Auto Rotation" onclick="toggleCameraAutoRotation()"><input type="checkbox" id="check_autorotation"><i class="material-icons"></i> Auto Rotation <i class="tooltip"><b>Toggle Auto Rotation</b><br>Enable/disable camera auto-rotation<br>Shortcut: [none]</i></li>
        <li class="spacer"></li>
        <li><label>Light &nbsp;<input title="Light Position" type="number" value="120" min="0" max="360" step="10" oninput="setLightPositionByAngle(scene.lights[1], this.value, 50, 100); updateShadowMap();"> °</label><i class="tooltip"><b>Light Position</b><br>Set light position by angle<br>Shortcut: [none]</i></li>
        <li class="category">SCENE</li>
        <li><button title="Optimize Scene" onclick="optimize()">Optimize Scene</button><i class="tooltip"><b>Optimize Scene</b><br>Optimize scene for maximum performance<br>Shortcut: [none]</i></li>
        <li><button title="Toggle Debug Tools" onclick="toggleDebugMode()">Debug Mode</button><i class="tooltip"><b>Toggle Debug Tools</b><br>Show/hide Babylon.js debug layer, open menu to hide it<br>Shortcut: [none]</i></li>
        <li class="category">ABOUT</li>
        <li style="text-align: center; font-size: 10px;"><a href="https://github.com/nimadez/voxel-builder">Fork me on GitHub</a><br><a href="https://nimadez.github.io/">©2019 nimadez</a></li>
    </ul>
    <ul id="toolbar_L">
        <li title="Minimal Interface [`]" onclick="toggleMinimalInterface(false)"><i class="material-icons">self_improvement</i><i class="tooltip"><b>Minimal Interface (Zen Mode)</b><br>Toggle minimal interface mode, switch to minimal interface for better mobile experience, click on View Cube to maximize interface.<br>Shortcut [`]</i></li>
        <li title="Fit Camera [C]" onclick="fitCameraToMesh()"><i class="material-icons">filter_center_focus</i><i class="tooltip"><b>Fit Camera</b><br>Reset camera and fit to model<br>Shortcut [C]</i></li>
        <li class="separator"></li>
        <li title="Paint Color [Q]" class="paint" onclick="toolSelector('paint', false)"><i class="material-icons">brush</i><i class="tooltip"><b>Paint Color</b><br>Paint selected color (undoable)<br>Shortcut: [Q]</i></li>
        <li title="Fill Color [I]" class="fillcolor" onclick="toolSelector('fillcolor', false)"><i class="material-icons">format_paint</i><i class="tooltip"><b>Fill Color</b><br>Fill and replace all similar colors<br>Shortcut: [I]</i></li>
        <li class="separator"></li>
        <li title="Pick Color [P]" class="pickcolor" onclick="toolSelector('pickcolor', false)"><i class="material-icons">colorize</i><i class="tooltip"><b>Pick Color</b><br>Pick voxel color, color palette created on the fly<br>Shortcut: [P]</i></li>
        <li title="Color Picker" class="colorpicker" onclick="document.getElementById('inputcolor').click()"><input type="color" id="inputcolor" value="#3876C0"><i class="tooltip"><b>Color Picker</b><br>Pick a color, color palette created on the fly<br>Shortcut: [none]</i></li>
    </ul>
    <ul id="toolbar_R">
        <li title="Quick Restore" onclick="getStorage()"><i class="material-icons">restore</i><i class="tooltip"><b>Quick Restore</b><br>Restore model from local storage, It is persistent as long as the user chooses to clear the browser data.<br>Shortcut [none]</i></li>
        <li title="Quick Save" onclick="setStorage()"><i class="material-icons">save</i><i class="tooltip"><b>Quick Save</b><br>Save model to local storage, It is persistent as long as the user chooses to clear the browser data.<br>Shortcut [none]</i></li>
        <li class="separator"></li>
        <li title="Hide Voxels [H]" class="hide" onclick="toolSelector('hide', false)"><i class="material-icons">layers_clear</i><i class="tooltip"><b>Hide Voxels</b><br>Hide selected voxels, don't forget to apply "Freeze Visibility", or reset visibility using "Unhide All".<br>Shortcut: [H]</i></li>
        <li title="Hide Voxels By Color [J]" class="hidecolor" onclick="toolSelector('hidecolor', false)"><i class="material-icons">invert_colors_off</i><i class="tooltip"><b>Hide Voxels By Color</b><br>Hide voxels by color, don't forget to apply "Freeze Visibility", or reset visibility using "Unhide All".<br>Shortcut: [J]</i></li>
        <li title="Unhide All" class="unhideall" onclick="setParticlesVisibility(true)"><i class="material-icons">restart_alt</i><i class="tooltip"><b>Unhide All</b><br>Show all voxels, ignore changes and reset visibility<br>Shortcut: [none]</i></li>
        <li title="Freeze Visibility" class="freezevisibility" onclick="freezeVisibility()"><i class="material-icons">ac_unit</i><i class="tooltip"><b>Freeze Visibility</b><br>Remove all hidden voxels (undoable)<br>Shortcut: [none]</i></li>
        <li class="separator"></li>
        <li title="Normalize Position" class="normalize" onclick="normalizeVoxelPositions()"><i class="material-icons">equalizer</i><i class="tooltip"><b>Normalize Position</b><br>Move to center and drop to ground (undoable)<br>Shortcut: [none]</i></li>
    </ul>
    <ul id="hover">
        <li title="Free Camera [S]" class="camera" onclick="toolSelector('camera', false)" onpointerdown="dragElement(this)"><i class="material-icons">control_camera</i><i class="tooltip"><b>Free Camera</b><br>Switch to camera mode and disable tools<br>Shortcut: [S]</i></li>
        <li title="Add [W]" class="add" onclick="toolSelector('add', true)"><i class="material-icons">create</i><i class="tooltip"><b>Add</b><br>Add new voxels, support undo and symmetry<br>Shortcut: [W]</i></li>
        <li title="Remove [D]" class="remove" onclick="toolSelector('remove', true)"><i class="material-icons">clear</i><i class="tooltip"><b>Remove</b><br>Remove voxels, support undo and symmetry<br>Shortcut: [D]</i></li>
        <li title="Transform [A]" class="transform" onclick="toolSelector('transform', true)"><i class="material-icons">border_inner</i><i class="tooltip"><b>Transform</b><br>Translate in selected axis, support undo and symmetry<br>Shortcut: [A]</i></li>
    </ul>
    <ul id="axisview" onclick="toggleMinimalInterface(true)">
        <li title="Grid Texture" onclick="toggleShowGridTexture(); toggleButton(this)"><i class="material-icons" style="font-size:14px">grain</i><i class="tooltip"><b>Toggle Grid Texture</b><br>Enable/disable grid texture visibility<br>Shortcut: [none]</i></li>
        <li title="Bounding Box" onclick="toggleBoundingBox(); toggleButton(this)""><i class="material-icons" style="font-size:14px">select_all</i><i class="tooltip"><b>Toggle Bounding Box</b><br>Enable/disable bounding box visibility<br>Shortcut: [none]</i></li>
        <li title="Wireframe" onclick="toggleShowWireframe(); toggleButton(this)"><i class="material-icons" style="font-size:14px">flip</i><i class="tooltip"><b>Toggle Wireframe</b><br>Enable/disable wireframe visibility<br>Shortcut: [none]</i></li>
        <li title="Shadow Catcher" onclick="toggleShadowCatcher(); toggleButton(this)"><i class="material-icons" style="font-size:14px">brightness_6</i><i class="tooltip"><b>Toggle Shadow Catcher</b><br>Enable/disable shadow catcher visibility<br>Shortcut: [none]</i></li>
        <li title="Scene Grid" onclick="toggleGrid(); toggleButton(this)"><i class="material-icons"  style="font-size:14px">remove</i><i class="tooltip"><b>Toggle Scene Grid</b><br>Enable/disable scene grid visibility<br>Shortcut: [none]</i></li>
    </ul>
    <div id="symmetryaxis" title="Symmetry Draw and Paint">
        <ul>
            <li style="color: #999;" onclick="setSymmetryAxis('', this)" class="selected">N</li>
            <li style="color: #ee4951;" onclick="setSymmetryAxis('x', this)">X</li>
            <li style="color: #34c239;" onclick="setSymmetryAxis('y', this)">Y</li>
            <li style="color: #529dff;" onclick="setSymmetryAxis('z', this)">Z</li>
        </ul>
        <i class="tooltip"><b>Symmetric Draw and Paint</b><br>Select axis to show indicator<br>Support Add, Remove, Transform and Paint Color<br>Shortcut: [none]</i>
    </div>
    <!-- dynamic -->
    <ul id="color_palette" title="Color Palette"></ul>
    <div id="notifier"></div>
    <div id="status"><span id="fps" style="font-size: 11px">00</span> | <span id="voxels">0</span><i> voxels</i> <span id="verts">0</span><i> verts</i></div>
    <div id="help"><div class="tip"><b>Introduction</b><br>Here you will find a short instruction to learn the basics and keyboard shortcuts. Visit <a href="https://github.com/nimadez/voxel-builder">GitHub Repository</a> for more technical information, requests and bug reports.</div></div>
    <div id="helpbtn"><button><i class="material-icons">live_help</i></button></div>
    <!-- hidden -->
    <div style="display: none" id="show_menuV" onclick="document.getElementById('menuV').style.transform = 'translate(0, 0)'"></div>
    <div style="display: none" id="hide_menuV" onclick="document.getElementById('menuV').style.transform = 'translate(200px, 0)'"></div>
    <input style="display: none" type="file" id="openfile_vox" accept=".vox" onclick="this.value = null">
    <input style="display: none" type="file" id="openfile_obj" accept=".obj" onclick="this.value = null">
    <input style="display: none" type="file" id="openfile_hdr" accept=".hdr" onclick="this.value = null">
</body>
<script>
    const canvas = document.querySelectorAll('canvas')[0];
    const numFps = document.getElementById('fps');
    const notifier = document.getElementById('notifier');
    const inputColor = document.getElementById('inputcolor');
    const memBlocks = document.querySelectorAll('#menuH_C li');
    const MAXAMOUNT = 64000;
    let currentColor = inputColor.value.toUpperCase();
    let symmetryAxis = ''; //'x'
    let showVerticalMenu = true;
    let memStep = 0;

    // -----------------------------------------------------------------------------------
    // Engine/RenderLoop -----------------------------------------------------------------

    const engine = new BABYLON.Engine(canvas, true, null, false);
    engine.disablePerformanceMonitorInBackground = true;
    engine.enableOfflineSupport = false;
    engine.doNotHandleContextLost = true;
    engine.useHighPrecisionFloats = false;
    engine.loadingUIBackgroundColor = "#000000e1";

    const scene = createScene(engine);
    const sceneAxisView = createAxisViewScene(engine);
    
    engine.runRenderLoop(function () {
        beginPerformanceMonitor();
        scene.render();
        sceneAxisView.render();
        sceneAxisView.activeCamera.alpha = scene.activeCamera.alpha;
        sceneAxisView.activeCamera.beta = scene.activeCamera.beta;
        endPerformanceMonitor();
    });
    
    // -----------------------------------------------------------------------------------
    // Main Scene ------------------------------------------------------------------------

    function createScene(engine) {
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
        scene.autoClear = false;
        scene.autoClearDepthAndStencil = false;
        scene.blockMaterialDirtyMechanism = true;
        //scene.debugLayer.show();

        const camera = new BABYLON.ArcRotateCamera("camera", 0, 0, 10, BABYLON.Vector3.Zero(), scene);
        camera.attachControl(canvas, true);
        camera.setTarget(new BABYLON.Vector3(0, 2, 0));
        camera.panningSensibility = 300;
        camera.wheelPrecision = 10;
        camera.lowerRadiusLimit = 5;
        camera.upperRadiusLimit = 200;
        if (isMobileDevice()) camera.pinchPrecision = 100;

        const ambient = new BABYLON.HemisphericLight("ambient", new BABYLON.Vector3(0, 1, 0), scene);
        ambient.diffuse = new BABYLON.Color3(0.5, 0.5, 0.5);
        ambient.specular = new BABYLON.Color3(0, 0, 0);
        ambient.groundColor = new BABYLON.Color3(0.4, 0.4, 0.4);
        ambient.intensity = 0.3;

        const light = new BABYLON.DirectionalLight("light", new BABYLON.Vector3(0, -1, 0), scene);
        setLightPositionByAngle(light, 120, 50, 100);
        light.autoUpdateExtends = true;
        light.diffuse = new BABYLON.Color3(1, 1, 1);
        light.intensity = 1;

        const shadowGen = new BABYLON.ShadowGenerator(1024, light); // shadows updated manually on SPS.mesh changes,
        shadowGen.getShadowMap().refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONCE; // to save performance
        shadowGen.filteringQuality = BABYLON.ShadowGenerator.QUALITY_LOW;
        shadowGen.useExponentialShadowMap = true;
        shadowGen.usePoissonSampling = true;
        shadowGen.forceBackFacesOnly = false;
        shadowGen.setDarkness(0.5);

        const grid = BABYLON.MeshBuilder.CreateGround("grid", {width: 20, height: 20}, scene);
        grid.material = new BABYLON.GridMaterial("grid", scene);
        grid.material.backFaceCulling = false;
        grid.material.gridRatio = 1;
        grid.material.mainColor = new BABYLON.Color3(0.6, 0.6, 0.6);
        grid.material.lineColor = new BABYLON.Color3(0.7, 0.7, 0.7);
        grid.material.opacity = 0.3;
        grid.material.freeze();
        grid.position.y = -0.5;
        grid.isPickable = false;
        grid.doNotSyncBoundingInfo = true;
        grid.convertToUnIndexedMesh();
        grid.freezeWorldMatrix();
        grid.freezeNormals();

        const shadowcatcher = BABYLON.MeshBuilder.CreateGround("shadowcatcher", {width: 100, height: 100}, scene);
        shadowcatcher.material = new BABYLON.ShadowOnlyMaterial('shadowcatcher', scene);
        shadowcatcher.material.shadowColor = new BABYLON.Color3.FromHexString('#161a20');
        shadowcatcher.material.activeLight = light;
        shadowcatcher.material.backFaceCulling = true;
        shadowcatcher.material.alpha = 0.3;
        shadowcatcher.position.y = -0.5;
        shadowcatcher.receiveShadows = true;
        shadowcatcher.isPickable = false;
        shadowcatcher.doNotSyncBoundingInfo = true;
        shadowcatcher.convertToUnIndexedMesh();
        shadowcatcher.freezeWorldMatrix();
        shadowcatcher.freezeNormals();

        return scene;
    }

    // -----------------------------------------------------------------------------------
    // Axis-View Scene -------------------------------------------------------------------

    function createAxisViewScene(engine) {
        const scene = new BABYLON.Scene(engine);
        scene.autoClear = false;
        scene.autoClearDepthAndStencil = false;
        scene.blockMaterialDirtyMechanism = true;

        const ambient = new BABYLON.HemisphericLight("ambient", new BABYLON.Vector3(0, -1, 0), scene);
        ambient.diffuse = new BABYLON.Color3(1, 1, 1);
        ambient.groundColor = new BABYLON.Color3(0.5, 0.5, 0.5);
        ambient.intensity = 3.0;

        const camera = new BABYLON.ArcRotateCamera("camera", 0, 0, 10, BABYLON.Vector3.Zero(), scene);
        camera.viewport = updateViewport(80, 80, 0, 0);
        camera.radius = 3;

        const cube = BABYLON.MeshBuilder.CreateBox("viewcube", {}, scene);
        cube.material = new BABYLON.NormalMaterial("viewcube", scene);
        cube.material.backFaceCulling = true;
        cube.material.alpha = 0.9;
        cube.material.freeze();
        cube.doNotSyncBoundingInfo = true;
        cube.enableEdgesRendering();
        cube.edgesWidth = 2;
        cube.edgesColor = new BABYLON.Color4.FromHexString('#3b404e'+'FF');
        cube.convertToUnIndexedMesh(); // after edgesRendering
        cube.freezeWorldMatrix();
        cube.freezeNormals();

        return scene;
    }

    // -----------------------------------------------------------------------------------
    // Materials -------------------------------------------------------------------------

    const gridTexture = createGridTexture();
    const defaultMaterial = createMaterial(gridTexture);

    function createGridTexture() {
        const texture = new BABYLON.DynamicTexture('dynagrid', 128, scene, BABYLON.Texture.LINEAR_LINEAR);
        const ctx = texture.getContext();
        ctx.lineWidth = 2; // draw grid
        ctx.strokeStyle = "#CCCCCC";
        ctx.beginPath();
        ctx.moveTo(0, 64);
        ctx.lineTo(128, 64);
        ctx.moveTo(64, 0);
        ctx.lineTo(64, 128);
        ctx.stroke();
        ctx.lineWidth = 4; // draw outline
        ctx.strokeStyle = "#FFFFFF";
        ctx.strokeRect(0, 0, 128, 128);
        texture.update();
        texture.hasAlpha = true;
        return texture;
    }

    function createMaterial(gridTex) {
        const mat = new BABYLON.PBRMaterial("defaultMaterial", scene);
        mat.backFaceCulling = true;
        mat.albedoColor = new BABYLON.Color3(1, 1, 1);
        mat.emissiveIntensity = 0.2;
        mat.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
        mat.emissiveTexture = gridTex;
        mat.reflectionTexture = gridTex;
        mat.metallic = 0;
        mat.roughness = 0.75;
        mat.cameraContrast = 2; // mimic toon shading
        mat.cameraExposure = 1;
        mat.environmentIntensity = 1;
        return mat;
    }

    // -----------------------------------------------------------------------------------
    // Voxels ----------------------------------------------------------------------------

    let voxels = []; // 2D array: [0]position(vector3) [1]color(hex uppercase no-opacity)
    let SPS = null;

    function createBlock(data) {
        if (voxels.length > 0)
            voxels = [];
        for (let i in data)
            addVoxel(data[i].position, data[i].color);
        createSPS();
        updateShadowMap();
        createPalette();
        // reset toggles
        clearAllToggles();
        clearAllToggleButtons();
    }

    function addVoxel(pos, hex) {
        voxels.push({ position: pos, color: hex });
    }

    function removeVoxel(pos) {
        let index = -1;
        for (let i in voxels) { // need to find voxel by position, because array index
            if (voxels[i].position.equals(pos)) { // changes after multiple removes
                index = voxels.indexOf(voxels[i]);
                if (index > -1)
                    voxels.splice(index, 1);
                return; // find voxel, break loop
            }
        }
    }

    function createSPS() {
        if (SPS) {
            SPS.dispose();
            SPS = null;
        }
        SPS = new BABYLON.SolidParticleSystem('SPS', scene, { isPickable: true, updatable: true });

        const builder = function(particle, i, s) { // s = index shape
            particle.position.copyFrom(voxels[i].position);
            particle.color = new BABYLON.Color4.FromHexString(voxels[i].color + 'FF');
        }
        const voxel = BABYLON.MeshBuilder.CreateBox("voxel", {}, scene);
        SPS.addShape(voxel, voxels.length, { positionFunction: builder });
        voxel.dispose();

        const mesh = SPS.buildMesh();
        mesh.material = defaultMaterial;
        mesh.receiveShadows = true;
        mesh.doNotSyncBoundingInfo = true;
        mesh.cullingStrategy = BABYLON.AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;
        mesh.freezeWorldMatrix();
        mesh.freezeNormals();
        scene.lights[1].getShadowGenerator().addShadowCaster(mesh);

        SPS.initParticles();
        SPS.setParticles();         // update SPS mesh and draw it
        SPS.refreshVisibleSize();   // update BBox for picking and shadows
        SPS.computeBoundingBox = true;
        SPS.computeParticleColor = true;
        SPS.computeParticleRotation = false;
        SPS.computeParticleTexture = false;
        SPS.computeParticleVertex = false;
        updateStatus();
    }

    function updateSPS() {
        SPS.setParticles();
        updateShadowMap();
    }

    function updateParticle(index) {
        SPS.setParticles(index, index, true);
        updateShadowMap();
    }

    function setVoxelPosition(index, pos) {
        voxels[index].position = pos;
        SPS.particles[index].position = pos;
    }

    function setVoxelColor(index, hex) {
        voxels[index].color = hex;
        SPS.particles[index].color = new BABYLON.Color4.FromHexString(hex + 'FF');
    }

    // generate color palette from current voxel colors
    function createPalette() {
        document.getElementById('color_palette').innerHTML = ""; // clear palette
        let uniqueColors = [];
        for (let i in voxels) {
            if (uniqueColors.indexOf(voxels[i].color) == -1) {
                addColorToPalette(voxels[i].color);
                uniqueColors.push(voxels[i].color);
            }
        }
        uniqueColors = null;
    }

    // -----------------------------------------------------------------------------------
    // Overlays & Helpers ----------------------------------------------------------------

    let dummyVoxels = []; // fake voxels for visualization

    const overlayCube = BABYLON.MeshBuilder.CreateBox("overlay_cube", {}, scene);
    overlayCube.isVisible = false;
    overlayCube.isPickable = false;
    overlayCube.visibility = 0.1;
    overlayCube.renderOverlay = true;
    overlayCube.overlayAlpha = 0.5;
    overlayCube.edgesWidth = 2;
    overlayCube.doNotSyncBoundingInfo = true;
    overlayCube.enableEdgesRendering();
    overlayCube.convertToUnIndexedMesh();
    overlayCube.freezeNormals();

    const overlayPlane = BABYLON.MeshBuilder.CreatePlane("overlay_plane", { sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
    overlayPlane.isVisible = false;
    overlayPlane.isPickable = false;
    overlayPlane.visibility = 0.1;
    overlayPlane.renderOverlay = true;
    overlayPlane.overlayAlpha = 0.5;
    overlayPlane.doNotSyncBoundingInfo = true;
    overlayPlane.convertToUnIndexedMesh();
    overlayPlane.freezeNormals();

    const dummyVoxel = BABYLON.MeshBuilder.CreateBox("dummy_voxel", {}, scene);
    dummyVoxel.isVisible = false;
    dummyVoxel.material = defaultMaterial;
    dummyVoxel.scaling.copyFromFloats(1.001, 1.001, 1.001); // prevent overlaps
    dummyVoxel.visibility = 1;
    dummyVoxel.renderOverlay = true;
    dummyVoxel.overlayAlpha = 0.3;
    dummyVoxel.doNotSyncBoundingInfo = true;
    dummyVoxel.convertToUnIndexedMesh();
    dummyVoxel.freezeWorldMatrix();
    dummyVoxel.freezeNormals();

    // used to indicate symmetry plane
    const workPlane = BABYLON.MeshBuilder.CreatePlane("workplane", { width: 20, height: 20, sideOrientation: BABYLON.Mesh.DOUBLESIDE }, scene);
    workPlane.isVisible = false;
    workPlane.isPickable = false;
    workPlane.visibility = 0.02;
    workPlane.renderOverlay = true;
    workPlane.overlayAlpha = 0.02;
    workPlane.overlayColor = new BABYLON.Color3.FromHexString('#ff00ff');
    workPlane.doNotSyncBoundingInfo = true;
    workPlane.convertToUnIndexedMesh();
    workPlane.freezeNormals();
    
    function setOverlayCube(pos, scale, hex) {
        overlayCube.isVisible = true;
        overlayCube.overlayColor = new BABYLON.Color3.FromHexString(hex);
        overlayCube.edgesColor = new BABYLON.Color4.FromHexString(hex + 'FF');
        overlayCube.position = pos;
        overlayCube.scaling = scale;
    }

    function setOverlayPlane(pos, normAxis, hex) {
        overlayPlane.isVisible = true;
        overlayPlane.overlayColor = new BABYLON.Color3.FromHexString(hex);
        overlayPlane.position = pos;
        const axis = BABYLON.Vector3.Cross(BABYLON.Axis.Z, normAxis);
        const angle = Math.acos(BABYLON.Vector3.Dot(normAxis, BABYLON.Axis.Z));
        overlayPlane.rotationQuaternion = BABYLON.Quaternion.RotationAxis(axis, angle);
    }

    function setWorkPlane(axis, scale) { //axis: BABYLON.Axis.X
        workPlane.isVisible = true;
        workPlane.position.y = -0.5;
        workPlane.scaling = new BABYLON.Vector3(scale, scale, scale);
        workPlane.rotation = BABYLON.Vector3.Zero();
        if (axis.x == 1) workPlane.rotation.y = Math.PI/2;
        if (axis.y == 1) workPlane.rotation.x = Math.PI/2;
        if (axis.z == 1) workPlane.rotation.z = Math.PI/2;
    }

    function cloneDummyVoxel(pos, hex) {
        const clone = dummyVoxel.clone();
        clone.isVisible = true;
        clone.position = pos;
        clone.overlayColor = new BABYLON.Color3.FromHexString(hex);
        dummyVoxels.push(clone);
    }

    function clearDummyVoxels() {
        if (dummyVoxels.length > 0) {
            for (let i in dummyVoxels)
                dummyVoxels[i].dispose();
            dummyVoxels = [];
        }
    }

    function clearOverlays() {
        overlayCube.isVisible = false;
        overlayPlane.isVisible = false;
    }

    function clearWorkPlane() {
        workPlane.isVisible = false;
    }

    // -----------------------------------------------------------------------------------
    // Tools -----------------------------------------------------------------------------

    let tool = 'camera';
    let selected = [];
    toolSelector('camera', false); // select startup tool

    function toolAdd(pos) {
        if (voxels.length >= MAXAMOUNT) {
            showNotification('you have reached the max amount! (64000 voxels)');
            return;
        }
        for (let i in selected) // no duplicates
            if (selected[i].equals(pos))
                return;
        addVoxel(pos, currentColor);
        cloneDummyVoxel(pos, "#00FF00");
        selected.push(pos);
    }

    function toolAddSymmetry(pos, axis) {
        if (axis == '') return;
        pos = symmetryInverse(pos, axis);
        for (let i in voxels) // no duplicates
            if (voxels[i].position.equals(pos))
                return;
        toolAdd(pos);
    }

    function toolRemove(pos) {
        if (voxels.length <= 1) return; // 1 voxel minimum
        for (let i in selected) // no duplicates
            if (selected[i].equals(pos))
                return;
        cloneDummyVoxel(pos, "#FF0000");
        selected.push(pos); // removing voxels later, prevent infinite-depth picking
    }

    function toolRemoveSymmetry(pos, axis) {
        if (axis == '') return;
        toolRemove(symmetryInverse(pos, axis));
    }

    function toolTransform(posBegin, posEnd, index) {
        for (let i in selected) // no duplicates
            if (selected[i].equals(posBegin))
                return;
        setVoxelPosition(index, posEnd);
        updateParticle(index, index, true);
        selected.push(posEnd);
    }

    function toolTransformSymmetry(posBegin, posEnd, index, axis) {
        if (axis == '') return;
        index = symmetryFinder(posBegin, axis);
        if (index == -1) return;
        posEnd = symmetryInverse(posEnd, axis);
        toolTransform(posBegin, posEnd, index);
    }

    function toolHide(particle) {
        cloneDummyVoxel(particle.position, "#FFFF00");
        selected.push(particle); // hiding voxels later, prevent infinite-depth picking
    }

    function toolPaint(index) {
        setVoxelColor(index, currentColor);
        updateParticle(index, index, true);
        selected.push(""); // need to refresh palette on toolSwitchEnd()
    }

    function toolPaintSymmetry(index, axis) {
        if (axis == '') return;
        index = symmetryFinder(voxels[index].position, axis);
        if (index == -1) return;
        toolPaint(index);
    }

    function toolPickColor(hexcolor) {
        inputColor.value = hexcolor;
        currentColor = hexcolor;
    }

    function toolFillColor(hexcolor) {
        for (let i in voxels) {
            if (voxels[i].color === hexcolor) {
                setVoxelColor(i, currentColor);
            }
        }
        selected.push("");
    }

    function toolHideColor(hexcolor) {
        let color = null;
        for (let i in SPS.particles) {
            color = SPS.particles[i].color.toHexString();
            color = color.substring(0, color.length - 2);
            if (color === hexcolor)
               SPS.particles[i].isVisible = false;
        }
        selected.push("");
    }
    
    function toolSwitchStart(pick) {
        if (pick.faceId == -1) return;
        const index = SPS.pickedParticles[pick.faceId].idx;
        const particle = SPS.particles[index];
        const pos = particle.position;
        const norm = pick.getNormal();
        switch (tool) {
            case 'add':
                setOverlayPlane(pos.add(norm.scale(0.5)), norm, '#00FF00');
                if (isMouseDown && pauseCameraControls()) {
                    toolAdd(pos.add(norm));
                    toolAddSymmetry(pos.add(norm), symmetryAxis);
                }
                break;
            case 'remove':
                setOverlayCube(pos, BABYLON.Vector3.One(), '#FF0000');
                if (isMouseDown && pauseCameraControls()) {
                    toolRemove(pos);
                    toolRemoveSymmetry(pos, symmetryAxis);
                }
                break;
            case 'transform':
                setOverlayCube(pos.add(norm), norm, '#00FFFF');
                setOverlayPlane(pos.add(norm.scale(0.5)), norm, '#00FFFF');
                if (isMouseDown && pauseCameraControls()) {
                    toolTransform(pos, pos.add(norm), index);
                    toolTransformSymmetry(pos, pos.add(norm), index, symmetryAxis);
                }
                break;
            case 'hide':
                setOverlayCube(pos, BABYLON.Vector3.One(), '#FFFF00');
                if (isMouseDown && pauseCameraControls())
                    toolHide(particle);
                break;
            case 'paint':
                setOverlayPlane(pos.add(norm.scale(0.5)), norm, currentColor);
                if (isMouseDown && pauseCameraControls()) {
                    toolPaint(index);
                    toolPaintSymmetry(index, symmetryAxis);
                }
                break;
            case 'pickcolor':
                setOverlayPlane(pos.add(norm.scale(0.5)), norm, voxels[index].color);
                if (isMouseDown && pauseCameraControls())
                    toolPickColor(voxels[index].color);
                break;
            case 'fillcolor':
                setOverlayPlane(pos.add(norm.scale(0.5)), norm, voxels[index].color);
                if (isMouseDown && pauseCameraControls())
                    toolFillColor(voxels[index].color);
                break;
            case 'hidecolor':
                setOverlayPlane(pos.add(norm.scale(0.5)), norm, voxels[index].color);
                if (isMouseDown && pauseCameraControls()) {
                    toolHideColor(voxels[index].color);
                    isMouseDown = false; // only once
                }
                break;
        }
    }

    function toolSwitchEnd() {
        if (selected.length == 0) return;
        switch (tool) {
            case 'add':
                createSPS();
                createPalette();
                break;
            case 'remove':
                for (let i in selected)
                    removeVoxel(selected[i]);
                createSPS();
                createPalette();
                break;
            case 'hide':
                for (let i in selected)
                    selected[i].isVisible = false;
                updateSPS();
                break;
            case 'paint':
                createPalette();
                break;
            case 'fillcolor':
                updateSPS();
                createPalette();
                break;
            case 'hidecolor':
                updateSPS();
                break;
        }
        clearDummyVoxels();
        selected = [];

        // store memory if the tool is not excluded
        const ignoredTools = ['hide', 'hidecolor'];
        if (!ignoredTools.includes(tool)) {
            memStep += 1;
            saveMemory(memStep);
        }
    }

    function toolSelector(toolName, forceUnHideAll) {
        tool = toolName;
        if (forceUnHideAll) setParticlesVisibility(true);
        clearButtons(document.getElementsByClassName(toolName)[0]);
    }

    function symmetryFinder(pos, axis) {
        pos = symmetryInverse(pos, axis);
        for (let i in voxels) {
            if (voxels[i].position.equals(pos))
                return i; // return voxel index at certain mirrored position
        }
        return -1;
    }

    function symmetryInverse(pos, axis) {
        if (axis == 'x') pos = new BABYLON.Vector3(-pos.x, pos.y, pos.z);
        if (axis == 'y') pos = new BABYLON.Vector3(pos.x, -(pos.y+1), pos.z);
        if (axis == 'z') pos = new BABYLON.Vector3(pos.x, pos.y, -pos.z);
        return pos;
    }

    // -----------------------------------------------------------------------------------
    // Interactions ----------------------------------------------------------------------
    
    let isMouseDown = false;
    let lastCamPos = null;
    let pick = null;

    function handleToolDown(e) {
        if (tool == 'camera') return; // speed up navigation
        isMouseDown = true;
        lastCamPos = scene.activeCamera.position.clone();
        pick = scene.pick(scene.pointerX, scene.pointerY, function (mesh) { return mesh === SPS.mesh });
        if (pick.hit)
            toolSwitchStart(pick);
    }

    function handleToolMove(e) {
        if (tool == 'camera') return;
        const t = setTimeout(function() { // picking is 100% faster when set timeout, test: try 10000 voxels.
            pick = scene.pick(scene.pointerX, scene.pointerY, function (mesh) { return mesh === SPS.mesh });
            if (pick.hit) {
                toolSwitchStart(pick);
            } else {
                clearOverlays();
            }
            clearTimeout(t);
        }, 1000 / 30);
    }

    function handleToolUp(e) {
        if (tool == 'camera') { clearOverlays(); return; }
        isMouseDown = false;
        toolSwitchEnd();
        updateShadowMap();
        scene.activeCamera.attachControl(canvas, true);
    }

    function pauseCameraControls() { // prevent tools and camera-controls conflict
        if (!lastCamPos.equals(scene.activeCamera.position)) return false;
        scene.activeCamera.detachControl(canvas);
        return true;
    }

    // -----------------------------------------------------------------------------------
    // HDR & Rendering -------------------------------------------------------------------

    let hdrTexture = null;
    let skybox = null;
    let ssao = null;
    let pipeline = null;

    function createHDR(url) {
        if (hdrTexture && skybox)
            removeHDR();
        hdrTexture = new BABYLON.HDRCubeTexture(url, scene, 512);
        hdrTexture.gammaSpace = true;
        scene.environmentTexture = hdrTexture;
        defaultMaterial.reflectionTexture = hdrTexture;
        defaultMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
        skybox = scene.createDefaultSkybox(hdrTexture, true, (scene.activeCamera.maxZ - scene.activeCamera.minZ) / 2, 0.2, true);
        document.getElementById('check_skybox').checked = true;
    }

    function removeHDR() {
        if (hdrTexture && skybox) {
            if (!confirm("This operation is not undoable, continue?")) return;
            scene.getMaterialByName("skyBox").getActiveTextures()[0].dispose();
            scene.getMaterialByName("skyBox").dispose(); // skybox material not disposed successfuly
            skybox.dispose();
            hdrTexture.dispose();
            skybox = null;
            hdrTexture = null;
            defaultMaterial.reflectionTexture = gridTexture; // reset reflection
            defaultMaterial.reflectionTexture.coordinatesMode = 0; //default coordinate
            document.getElementById('check_skybox').checked = false;
        } else {
            showNotification('hdr map not loaded');
        }
    }

    function toggleSkybox() {
        if (skybox && skybox.isVisible) {
            skybox.isVisible = false;
            document.getElementById('check_skybox').checked = false;
        } else {
            if (skybox) {
                skybox.isVisible = true;
                document.getElementById('check_skybox').checked = true;
            } else {
                showNotification('hdr map not loaded');
                document.getElementById('check_skybox').checked = false;
            }
        }
    }

    function toggleHighQuality() {
        if (ssao && pipeline) {
            removeHighQuality();
        } else {
            ssao = new BABYLON.SSAORenderingPipeline("ssao", scene, { ssaoRatio: 0.5, combineRatio: 1.0 }, [scene.activeCamera]);
            ssao.fallOff = 0.00001;
            ssao.area = 1;
            ssao.radius = 0.0001;
            ssao.totalStrength = 0.9;
            ssao.base = 0.5;
            pipeline = new BABYLON.DefaultRenderingPipeline("default", false, scene, [scene.activeCamera]); //false:hdr
            const curve = new BABYLON.ColorCurves();
            curve.globalHue = 200;
            curve.globalDensity = 80;
            curve.globalSaturation = 80;
            curve.highlightsHue = 20;
            curve.highlightsDensity = 80;
            curve.highlightsSaturation = -80;
            curve.shadowsHue = 2;
            curve.shadowsDensity = 80;
            curve.shadowsSaturation = 40;
            pipeline.imageProcessingEnabled = true;
            pipeline.imageProcessing.toneMappingEnabled = true;
            pipeline.imageProcessing.contrast = 0;
            pipeline.imageProcessing.exposure = 0;
            pipeline.imageProcessing.colorCurvesEnabled = true;
            pipeline.imageProcessing.colorCurves = curve;
            pipeline.fxaaEnabled = true; //pipeline.samples = 4;
            pipeline.sharpenEnabled = true;
            pipeline.sharpen.edgeAmount = 0.2;
            pipeline.sharpen.colorAmount = 1.0;
            pipeline.bloomEnabled = true;
            pipeline.bloomThreshold = 0.8;
            pipeline.bloomWeight = 0.3;
            pipeline.bloomKernel = 64;
            pipeline.bloomScale = 0.5;
            pipeline.chromaticAberrationEnabled = true;
            pipeline.chromaticAberration.aberrationAmount = 150;
            pipeline.chromaticAberration.radialIntensity = 5;
            pipeline.chromaticAberration.direction.x = Math.sin(Math.PI);
            pipeline.chromaticAberration.direction.y = Math.cos(Math.PI);
            pipeline.grainEnabled = true;
            pipeline.grain.intensity = 2;
            pipeline.grain.animated = false;
            pipeline.depthOfFieldEnabled = false;
            pipeline.depthOfFieldBlurLevel = BABYLON.DepthOfFieldEffectBlurLevel.Low;
            pipeline.depthOfField.focusDistance = SPS.mesh.getDistanceToCamera(scene.activeCamera);
            pipeline.depthOfField.focalLength = 35;
            pipeline.depthOfField.fStop = 1.4;
            pipeline.depthOfField.lensSize = 100;
        }
    }

    function removeHighQuality() {
        if (ssao && pipeline) {
            ssao.dispose();
            ssao = null;
            pipeline.dispose();
            pipeline = null;
        }
    }

    // -----------------------------------------------------------------------------------
    // Files -----------------------------------------------------------------------------

    function newProject() {
        if (!confirm("Discard current project?")) return;
        let data = [];
        data.push({ position: new BABYLON.Vector3(0.5, 0, 0.5),   color: currentColor });
        data.push({ position: new BABYLON.Vector3(-0.5, 0, -0.5), color: currentColor });
        data.push({ position: new BABYLON.Vector3(-0.5, 0, 0.5),   color: currentColor });
        data.push({ position: new BABYLON.Vector3(0.5, 0, -0.5), color: currentColor });
        createBlock(data);
        fitCameraToMesh();
        clearMemory();
        data = null;
    }

    function loadProject(voxdata) {
        const lines = voxdata.split('\n');
        let data = [];
        let chunk = [];
        let line = '';
        for (let i in lines) {
            if (lines[i]) { // ignore empty lines
                line = lines[i].replace(/\s+/g, ''); // strip whitespaces
                chunk = line.split(',');
                data.push({ 
                    position: new BABYLON.Vector3(parseFloat(chunk[0]), parseFloat(chunk[1]), parseFloat(chunk[2])),
                    color: chunk[3]
                });
            }
        }
        createBlock(data);
        fitCameraToMesh();
        clearMemory();
        data = null;
    }

    function saveProject() {
        let data = '';
        for (let i in voxels)
            data += voxels[i].position.x + ',' + voxels[i].position.y + ',' + voxels[i].position.z + ',' + voxels[i].color + '\n';
        downloadFile(data, 'project.vox');
        data = null;
    }

    function importMesh(url, ext) {
        const scale = document.getElementById('user-input-voxelization-scale').value;
        engine.displayLoadingUI();
        BABYLON.SceneLoader.LoadAssetContainerAsync(url, "", scene, null, ext).then(function(container) {
            const mesh = BABYLON.Mesh.MergeMeshes(container.meshes, true, true);
            normalizeImportedMesh(mesh, scale);
            let pointData = getRandomPointsOnMeshSurface(mesh);
            const bounds = mesh.getBoundingInfo();
            const center = bounds.boundingBox.centerWorld;
            const size = getMeshSize(bounds);
            size.x = size.x / 2;
            size.y = size.y / 2;
            size.z = size.z / 2;
            mesh.dispose();

            if (pointData.length >= MAXAMOUNT) {
                pointData = null;
                engine.hideLoadingUI();
                showNotification("unable to import model, data is so big!");
                return;
            }

            let voxelGrid = [];
            for (let x = -size.x; x <= size.x; x++) {   // create grid of voxels
                for (let y = 0; y <= size.y * 2; y++) { // mesh dropped to floor with normalizeImportedMesh()
                    for (let z = -size.z; z <= size.z; z++) {
                        voxelGrid.push(new BABYLON.Vector3(center.x - x, y, center.z - z));
                    }
                }
            }

            // voxelization
            // we calculate random points per surface area,
            // voxel is 1x1x1, so larger mesh size equals to more voxels,
            // and longer surface require more points to fill details.
            let data = [];
            let unique = [];
            let distance = 0;
            for (let p = 0; p < pointData.length; p++) {
                for (let v = 0; v < voxelGrid.length; v++) {
                    distance = BABYLON.Vector3.Distance(pointData[p], voxelGrid[v]); // compare voxel position to point cloud data
                    if (distance <= 1 && unique.indexOf(voxelGrid[v]) == -1) {       // unique to prevent duplicates
                        data.push({ position: voxelGrid[v], color: currentColor });
                        unique.push(voxelGrid[v]);
                    }
                }
            }
            
            createBlock(data);
            fitCameraToMesh();
            clearMemory();
            
            data = null;
            unique = null;
            pointData = null;
            voxelGrid = null;
            engine.hideLoadingUI();

        }).catch(function(reason) {
            engine.hideLoadingUI();
            showNotification("unable to import model");
            console.error(reason.message);
        });
    }

    function exportMesh() {
        engine.displayLoadingUI();
        let mesh = SPS.mesh.clone();
        mesh.position.y += 0.5;
        const options = {
            shouldExportNode: function(node) {
                return node === mesh;
            }
        }
        BABYLON.GLTF2Export.GLBAsync(scene, "exported", options).then((glb) => {
            glb.downloadFiles();
            mesh.dispose();
            mesh = null;
            engine.hideLoadingUI();
        });
    }

    // -----------------------------------------------------------------------------------
    // Storage & Memory ------------------------------------------------------------------

    let memory = [];

    function setStorage() {
        if (voxels.length >= MAXAMOUNT) {
            showNotification("unable to store model, data is so big!");
            return;
        }
        localStorage.setItem("voxelstorage", JSON.stringify(voxels));
    }
    
    function getStorage() {
        let data = JSON.parse(localStorage.getItem("voxelstorage"));
        if (!data) {
            showNotification("empty storage");
            return;
        }
        if (!confirm("This operation is not undoable, continue?")) return;
        let newData = [];
        for (let i in data) {
            newData.push({
                position: new BABYLON.Vector3(data[i].position._x, data[i].position._y, data[i].position._z),
                color: data[i].color
            });
        }
        createBlock(newData);
        clearMemory();
        data = null;
        newData = null;
    }

    function saveMemory(step) {
        if (step > 9) step = 0;
        if (step < 0) step = 9;

        memory[step] = voxels.slice(0);

        for (let i of memBlocks)
            i.classList.remove("selected");
        memBlocks[step].classList.add("selected");
    }

    function loadMemory(step) {
        if (step > 9) step = 0;
        if (step < 0) step = 9;

        if (!memory[step]) return;
        createBlock(memory[step]);

        for (let i of memBlocks)
            i.classList.remove("selected");
        memBlocks[step].classList.add("selected");
        memStep = step;
    }

    // clear memory and initialize memory block 0
    function clearMemory() {
        memStep = 0;
        memory = [];
        saveMemory(0);
    }

    // switch memory blocks on click
    for (let i=0; i<memBlocks.length; i++) {
        memBlocks[i].addEventListener("click", function() {
            if (memory[i] !== undefined) {  // if storage is not empty
                for (let b of memBlocks) b.classList.remove("selected"); // unselect all
                this.classList.add("selected");
            } else {
                showNotification("empty memory");
            }
        }, false);
    }

    // -----------------------------------------------------------------------------------
    // Create ----------------------------------------------------------------------------

    function createGrid() {
        if (!confirm("Discard current project?")) return;
        const X = (document.getElementById('user-input-create-x').value - 1) / 2;
        const Y = (document.getElementById('user-input-create-y').value - 1) / 2;
        const Z = (document.getElementById('user-input-create-z').value - 1) / 2;
        let data = [];
        for (let x = -X; x <= X; x++) {
            for (let y = 0; y <= Y * 2; y++) {
                for (let z = -Z; z <= Z; z++) {
                    data.push({ position: new BABYLON.Vector3(x, y, z), color: currentColor });
                }
            }
        }
        createBlock(data);
        fitCameraToMesh();
        clearMemory();
        data = null;
    }

    // -----------------------------------------------------------------------------------
    // Events ----------------------------------------------------------------------------

    window.addEventListener("resize", function () { 
        engine.resize();
        updateAxisViewViewport();
        toggleMinimalInterface(true);
    }, false);

    canvas.addEventListener("pointerdown", handleToolDown, false);
    canvas.addEventListener("pointerup", handleToolUp, false);
    canvas.addEventListener("pointermove", handleToolMove, false);
    canvas.addEventListener("touchstart", handleToolDown, { passive: true });
    canvas.addEventListener("touchend", handleToolUp, false);
    canvas.addEventListener("touchmove", handleToolMove, { passive: true });
    scene.onDispose = function () {
        canvas.removeEventListener("pointerdown", handleToolDown);
        canvas.removeEventListener("pointerup", handleToolUp);
        canvas.removeEventListener("pointermove", handleToolMove);
        canvas.removeEventListener("touchstart", handleToolDown);
        canvas.removeEventListener("touchend", handleToolUp);
        canvas.removeEventListener("touchmove", handleToolMove);
    }

    document.getElementById('openfile_vox').addEventListener("change", function (e) {
        if (e.target.files.length > 0) {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = function() {
                loadProject(reader.result);
            }
            reader.readAsText(file);
        }
    }, false);

    document.getElementById('openfile_obj').addEventListener("change", function (e) {
        if (e.target.files.length > 0) {
            const file = e.target.files[0];
            const ext = file.name.substring(file.name.length - 4, file.name.length); //.ext
            const url = URL.createObjectURL(file);
            importMesh(url, ext);
            URL.revokeObjectURL(url);
        }
    }, false);

    document.getElementById('openfile_hdr').addEventListener("change", function (e) {
        if (e.target.files.length > 0) {
            const file = e.target.files[0];
            const url = URL.createObjectURL(file);
            createHDR(url);
            URL.revokeObjectURL(url);
        }
    }, false);

    inputColor.addEventListener("input", function (e) {
        currentColor = this.value.toUpperCase();
    }, false);

    canvas.addEventListener("keyup", function (e) {
        //console.log(e.key);
        switch (e.key) {
            case 'w':
                toolSelector('add', true);
                break;
            case 'a':
                toolSelector('transform', true);
                break;
            case 's':
                toolSelector('camera', true);
                break;
            case 'd':
                toolSelector('remove', true);
                break;
            case 'q':
                toolSelector('paint', false);
                break;
            case 'i':
                toolSelector('fillcolor', false);
                break;
            case 'p':
                toolSelector('pickcolor', false);
                break;
            case 'h':
                toolSelector('hide', false);
                break;
            case 'j':
                toolSelector('hidecolor', false);
                break;
            case 'c':
                fitCameraToMesh();
                break;
            case 'f':
                toggleFullscreen();
                break;
            case '`':
                toggleMinimalInterface(false);
                break;
        }
        if (e.ctrlKey && e.key === 'z') loadMemory(memStep - 1);
        if (e.ctrlKey && e.key === 'x') loadMemory(memStep + 1);
    }, false);

    document.addEventListener("keyup", function (e) {
        switch (e.key) {
            case ' ': //space key
                toggleVerticalMenu();
                break;
        }
        // F5 refresh for electron
        if (navigator.userAgent.toLowerCase().indexOf(' electron/') > -1)
            if (e.keyCode == 116) location.reload();
    }, false);

    // -----------------------------------------------------------------------------------
    // Functions -------------------------------------------------------------------------

    function setSymmetryAxis(axis, event) {
        // clear and re-set buttons
        for (let i of document.querySelectorAll('#symmetryaxis li'))
            i.classList.remove("selected");
        event.classList.add("selected");

        clearWorkPlane();
        const size = getMeshSize(SPS.mesh.getBoundingInfo());
        if (axis == '') {
            symmetryAxis = '';
        } else if (axis == 'x') {
            setWorkPlane(BABYLON.Axis.X, size.x/4);
            symmetryAxis = 'x';
        } else if (axis == 'y') {
            setWorkPlane(BABYLON.Axis.Y, size.y/4);
            symmetryAxis = 'y';
        } else if (axis == 'z') {
            setWorkPlane(BABYLON.Axis.Z, size.z/4);
            symmetryAxis = 'z';
        }
    }

    function normalizeImportedMesh(mesh, scale) {
        // normalize scale
        let bounds = mesh.getBoundingInfo();
        let size = getMeshSize(bounds);
        const scaleFactor = Math.min(scale / size.x, scale / size.y, scale / size.z);
        mesh.bakeTransformIntoVertices(BABYLON.Matrix.Scaling(scaleFactor, scaleFactor, scaleFactor));
        // center mesh and drop to floor
        bounds = mesh.getBoundingInfo();
        size = getMeshSize(bounds);
        const center = bounds.boundingBox.center;
        const newX = (-bounds.maximum.x) + (size.x / 2);
        const newY = (size.y / 2) - (center.y);
        const newZ = (-bounds.maximum.z) + (size.z / 2);
        mesh.bakeTransformIntoVertices(BABYLON.Matrix.Translation(newX, newY, newZ));
    }

    function normalizeVoxelPositions() {
        const bounds = SPS.mesh.getBoundingInfo();
        const size = getMeshSize(bounds);
        const center = bounds.boundingBox.center;
        const newX = (-bounds.maximum.x) + (size.x / 2);
        const newY = ((size.y / 2) - center.y) - 0.5;
        const newZ = (-bounds.maximum.z) + (size.z / 2);
        let pos = null;
        let mat = null;
        for (let i in voxels) {
            mat = BABYLON.Matrix.Translation(newX, newY, newZ);
            pos = BABYLON.Vector3.TransformCoordinates(voxels[i].position, mat);
            setVoxelPosition(i, pos);
        }
        updateSPS();

        // store memory
        memStep += 1;
        saveMemory(memStep);
    }

    function freezeVisibility() {
        if (!confirm("This operation is not undoable, continue?")) return;
        for (let i in SPS.particles) {
            if (!SPS.particles[i].isVisible) {
                removeVoxel(SPS.particles[i].position);
            }
        }
        createSPS();
        createPalette();

        // store memory
        memStep += 1;
        saveMemory(memStep);
    }

    function setParticlesVisibility(isVisible) {
        for (let i in SPS.particles)
            SPS.particles[i].isVisible = isVisible;
        updateSPS();
    }

    function fitCameraToMesh() {
        const bounds = SPS.mesh.getBoundingInfo().boundingSphere;
        const radius = bounds.radiusWorld;
        scene.activeCamera.setPosition(new BABYLON.Vector3(radius * 5, radius * 5, radius * 5));
        scene.activeCamera.setTarget(bounds.center.clone());
    }

    function toggleCameraAutoRotation() {
        scene.activeCamera.idleRotationWaitTime = 0;
        scene.activeCamera.useAutoRotationBehavior = !scene.activeCamera.useAutoRotationBehavior;
        document.getElementById('check_autorotation').checked = scene.activeCamera.useAutoRotationBehavior;
    }

    function clearAllToggles() {
        scene.getNodeByName("grid").isVisible = true;           //toggleGrid
        scene.getNodeByName("shadowcatcher").isVisible = true;  //toggleShadowCatcher
        defaultMaterial.wireframe = false;                      //toggleShowWireframe
        SPS.mesh.showBoundingBox = false;                       //toggleBoundingBox
        defaultMaterial.emissiveIntensity = 0.1;                //toggleShowGridTexture
        removeHighQuality();                                    //toggleHighQuality
    }

    function toggleGrid() {
        if (scene.getNodeByName("grid").isVisible) {
            scene.getNodeByName("grid").isVisible = false;
        } else {
            scene.getNodeByName("grid").isVisible = true;
        }
    }

    function toggleShadowCatcher() {
        if (scene.getNodeByName("shadowcatcher").isVisible) {
            scene.getNodeByName("shadowcatcher").isVisible = false;
        } else {
            scene.getNodeByName("shadowcatcher").isVisible = true;
        }
    }

    function toggleShowWireframe() {
        if (defaultMaterial.wireframe) {
            defaultMaterial.wireframe = false;
        } else {
            defaultMaterial.wireframe = true;
        }
    }

    function toggleShowGridTexture() {
        if (defaultMaterial.emissiveIntensity == 0) {
            defaultMaterial.emissiveIntensity = 0.1;
        } else {
            defaultMaterial.emissiveIntensity = 0;
        }
    }

    function toggleBoundingBox() {
        SPS.mesh.showBoundingBox = !SPS.mesh.showBoundingBox;
    }

    // -----------------------------------------------------------------------------------
    // Utilities: babylon ----------------------------------------------------------------

    function updateViewport(w, h, bottom, right) {
        const width = canvas.width;
        const height = canvas.height;
        return new BABYLON.Viewport(1 - (w + right) / width, 1 - (bottom + height) / height,   w / width, h / height);
    }

    function updateAxisViewViewport() {
        sceneAxisView.activeCamera.viewport = updateViewport(80, 80, 0, 0);
    }

    function updateShadowMap() {
        scene.lights[1].getShadowGenerator().getShadowMap().refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
    }

    function setLightPositionByAngle(light, angle, distance, height) {
        const x = Math.cos(angle * Math.PI / 180) * distance;
        const y = height;
        const z = Math.sin(angle * Math.PI / 180) * distance;
        const pos = new BABYLON.Vector3(x, y, z);
        light.position = pos; // our primary shadow light
        light.setDirectionToTarget(BABYLON.Vector3.Zero());
    }

    function getMeshSize(bounds) {
        const size = new BABYLON.Vector3();
        size.x = Math.abs(bounds.minimum.x - bounds.maximum.x);
        size.y = Math.abs(bounds.minimum.y - bounds.maximum.y);
        size.z = Math.abs(bounds.minimum.z - bounds.maximum.z);
        return size;
    }

    function getRandomPointsOnMeshSurface(mesh) {
        let positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
        let indices = mesh.getIndices();
        let points = [];
        let nPoints = 0;
        let id0 = 0, id1 = 0, id2 = 0;
        let v0X = 0, v0Y = 0, v0Z = 0, v1X = 0, v1Y = 0, v1Z = 0, v2X = 0, v2Y = 0, v2Z = 0;
        let vertex0 = BABYLON.Vector3.Zero(), vertex1 = BABYLON.Vector3.Zero(), vertex2 = BABYLON.Vector3.Zero();
        let vec0 = BABYLON.Vector3.Zero(), vec1 = BABYLON.Vector3.Zero(), vec2 = BABYLON.Vector3.Zero();
        let area = 0, crossX = 0, crossY = 0, crossZ = 0;
        let lamda = 0, mu = 0;
        for (let index = 0; index < indices.length / 3; index++) {
            id0 = indices[index * 3 + 0];
            id1 = indices[index * 3 + 1];
            id2 = indices[index * 3 + 2];
            v0X = positions[id0 * 3 + 0];
            v0Y = positions[id0 * 3 + 1];
            v0Z = positions[id0 * 3 + 2];
            v1X = positions[id1 * 3 + 0];
            v1Y = positions[id1 * 3 + 1];
            v1Z = positions[id1 * 3 + 2];
            v2X = positions[id2 * 3 + 0];
            v2Y = positions[id2 * 3 + 1];
            v2Z = positions[id2 * 3 + 2];
            vertex0.set(v0X, v0Y, v0Z);
            vertex1.set(v1X, v1Y, v1Z);
            vertex2.set(v2X, v2Y, v2Z);
            vertex1.subtractToRef(vertex0, vec0);
            vertex2.subtractToRef(vertex1, vec1);
            vertex2.subtractToRef(vertex0, vec2);
            crossX = (v0Y - v1Y) * (v2Z - v1Z) - (v0Z - v1Z) * (v2Y - v1Y); // calculate face area
            crossY = (v0Z - v1Z) * (v2X - v1X) - (v0X - v1X) * (v2Z - v1Z);
            crossZ = (v0X - v1X) * (v2Y - v1Y) - (v0Y - v1Y) * (v2X - v1X);
            area = Math.sqrt(crossX * crossX + crossY * crossY + crossZ * crossZ) * 0.5;
            nPoints = Math.round(3 * area); // density, num points per triangle
            for (let i = 0; i < nPoints; i++) { // create a point inside the facet v0, v1, v2
                lamda = BABYLON.Scalar.RandomRange(0, 1);
                mu = BABYLON.Scalar.RandomRange(0, 1);
                points.push( vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu)) );
            }
        }
        //DEBUG// for (let i in points) BABYLON.MeshBuilder.CreateSphere('dpoints', { diameter: 0.1, segments: 1 }, scene).position = points[i]; return;
        positions = null;
        indices = null;
        return points;
    }

    function optimize() {
        engine.displayLoadingUI();
        scene.activeCamera.detachControl(canvas);
        engine.clearInternalTexturesCache();
        scene.cleanCachedTextureBuffer();
        BABYLON.Tools.ClearLogCache();
        BABYLON.SceneOptimizer.OptimizeAsync(scene, BABYLON.SceneOptimizerOptions.LowDegradationAllowed(),
        function() {
            scene.activeCamera.attachControl(canvas, true);
            engine.hideLoadingUI();
            showNotification('optimized');
        }, function() {
            scene.activeCamera.attachControl(canvas, true);
            engine.hideLoadingUI();
            showNotification('optimization failed');
        });
    }

    function toggleDebugMode() {
        if (scene.debugLayer.isVisible()) {
            scene.debugLayer.hide();
            document.getElementById('toolbar_L').style.display = 'unset';
            document.getElementById('toolbar_R').style.display = 'unset';
            document.getElementById('menuH_L').style.display = 'unset';
            document.getElementById('menuH_C').style.display = 'unset';
            document.getElementById('axisview').style.display = 'unset';
            document.getElementById('hover').style.display = 'unset';
            document.getElementById('color_palette').style.display = 'unset';
            document.getElementById('symmetryaxis').style.display = 'unset';
            document.getElementById('help').style.display = 'unset';
            document.getElementById('helpbtn').style.display = 'unset';
            document.getElementById('status').style.display = 'unset';
        } else {
            scene.debugLayer.show();
            document.getElementById('toolbar_L').style.display = 'none';
            document.getElementById('toolbar_R').style.display = 'none';
            document.getElementById('menuH_L').style.display = 'none';
            document.getElementById('menuH_C').style.display = 'none';
            document.getElementById('axisview').style.display = 'none';
            document.getElementById('hover').style.display = 'none';
            document.getElementById('color_palette').style.display = 'none';
            document.getElementById('symmetryaxis').style.display = 'none';
            document.getElementById('help').style.display = 'none';
            document.getElementById('helpbtn').style.display = 'none';
            document.getElementById('status').style.display = 'none';
            toggleVerticalMenu(); // hide menu
        }
    }

    // -----------------------------------------------------------------------------------
    // Utilities: html -------------------------------------------------------------------

    let beginTime = (performance || Date).now(), prevTime = beginTime, frames = 0, fps = 0;
    function beginPerformanceMonitor() {
        beginTime = (performance || Date).now();
    }
    function endPerformanceMonitor() {
        frames ++;
        let time = (performance || Date).now();
        if (time >= prevTime + 1000) {
            fps = Math.round((frames * 1000) / (time - prevTime));
            prevTime = time;
			frames = 0;
            numFps.innerHTML = fps;
            if (fps < 50) numFps.style.color = 'red';
            else numFps.style.color = 'greenyellow';
        }
    }

    function updateStatus() {
        document.getElementById('voxels').innerHTML = voxels.length;
        document.getElementById('verts').innerHTML = SPS.mesh.getTotalVertices();
    }

    // dynamically create color(li) inside palette(ul)
    function addColorToPalette(hexcolor) {
        const li = document.createElement('li');
        li.style.backgroundColor = hexcolor;
        li.title = hexcolor;
        li.addEventListener("click", function() {
            inputColor.value = rgb2hex(this.style.backgroundColor);
            currentColor = rgb2hex(this.style.backgroundColor);
        });
        document.getElementById('color_palette').appendChild(li);
    }

    function rgb2hex(rgb) {
        rgb = rgb.replace('rgb(','').replace(')','').split(',');
        const result = rgb[2] | (rgb[1] << 8) | (rgb[0] << 16);
        const hex = '#' + (0x1000000 + result).toString(16).slice(1);
        return hex.toUpperCase();
    }

    function showNotification(txt) {
        notifier.innerHTML = txt.toUpperCase();
        notifier.style.marginLeft = -(notifier.getBoundingClientRect().width/2) + 'px';
        notifier.classList.toggle('fade');
        const t = setTimeout(function() {
            notifier.classList.toggle('fade');
            clearTimeout(t);
        }, 4000);
    }

    function toggleVerticalMenu() {
        showVerticalMenu = !showVerticalMenu;
        if (showVerticalMenu) {
            document.getElementById('hide_menuV').click();
        } else {
            document.getElementById('show_menuV').click();
        }
    }

    function clearButtons(li) {
        for (let i of document.querySelectorAll('li'))
            i.classList.remove("select");
        li.classList.add("select");
    }

    function toggleButton(li) {
        if (li.classList.contains("toggle"))
            li.classList.remove("toggle");
        else
            li.classList.add("toggle");
    }

    function clearAllToggleButtons() {
        for (let i of document.querySelectorAll('li'))
            i.classList.remove("toggle");
    }

    function toggleFullscreen() {
        if (document.fullscreenElement) {
            document.exitFullscreen();
            document.getElementById('check_fullscreen').checked = false;
        } else {
            document.body.requestFullscreen();
            document.getElementById('check_fullscreen').checked = true;
        }
    }

    let isMinimal = false;
    function toggleMinimalInterface(forceDisable) {
        if (isMinimal || forceDisable) {
            document.getElementById('toolbar_L').style.display = 'unset';
            document.getElementById('toolbar_R').style.display = 'unset';
            document.getElementById('menuH_R').style.display = 'unset';
            document.getElementById('menuH_L').style.display = 'unset';
            document.getElementById('menuH_C').style.display = 'unset';
            document.getElementById('color_palette').style.display = 'unset';
            document.getElementById('symmetryaxis').style.display = 'unset';
            document.getElementById('help').style.display = 'unset';
            document.getElementById('helpbtn').style.display = 'unset';
            document.getElementById('status').style.display = 'unset';
            for (let i = 0; i < document.querySelectorAll('#axisview li').length; i++) //toggle AxisView childs
                document.querySelectorAll('#axisview li')[i].style.display = 'unset';
            isMinimal = false;
        } else {
            document.getElementById('toolbar_L').style.display = 'none';
            document.getElementById('toolbar_R').style.display = 'none';
            document.getElementById('menuH_R').style.display = 'none';
            document.getElementById('menuH_L').style.display = 'none';
            document.getElementById('menuH_C').style.display = 'none';
            document.getElementById('color_palette').style.display = 'none';
            document.getElementById('symmetryaxis').style.display = 'none';
            document.getElementById('help').style.display = 'none';
            document.getElementById('helpbtn').style.display = 'none';
            document.getElementById('status').style.display = 'none';
            for (let i = 0; i < document.querySelectorAll('#axisview li').length; i++)
                document.querySelectorAll('#axisview li')[i].style.display = 'none';
            isMinimal = true;
        }
    }

    function downloadFile(txt, filename) {
        const blob = new Blob([ txt ], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
    }

    function isMobileDevice() {
        if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) 
            || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0,4))) { 
            return true;
        }
        return false;
    }

    // make div draggable, elem is a move handle and elem.parentElement is our movable div
    let xOffset = 0, yOffset = 0;
    function dragElement(elem) {
        let active = false;
        let currentX, currentY, initialX, initialY;

        // prevent fast-dragging problem with background elements
        document.body.addEventListener("pointerdown", dragStart, false);
        document.body.addEventListener("pointerup", dragEnd, false);
        document.body.addEventListener("pointermove", drag, false);
        document.body.addEventListener("touchstart", dragStart, false);
        document.body.addEventListener("touchend", dragEnd, false);
        document.body.addEventListener("touchmove", drag, false);

        function dragStart(e) {
            if (e.type === "touchstart") {
                initialX = e.touches[0].clientX - xOffset;
                initialY = e.touches[0].clientY - yOffset;
            } else {
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
            }
            if (e.target === elem)
                active = true;
        }

        function dragEnd(e) {
            initialX = currentX;
            initialY = currentY;
            active = false;
            document.body.removeEventListener("pointerdown", dragStart, false);
            document.body.removeEventListener("pointerup", dragEnd, false);
            document.body.removeEventListener("pointermove", drag, false);
            document.body.removeEventListener("touchstart", dragStart, false);
            document.body.removeEventListener("touchend", dragEnd, false);
            document.body.removeEventListener("touchmove", drag, false);
        }

        function drag(e) {
            if (active) {
                if (e.type === "touchmove") {
                    currentX = e.touches[0].clientX - initialX;
                    currentY = e.touches[0].clientY - initialY;
                } else {
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                }
                xOffset = currentX;
                yOffset = currentY;
                setTranslate(currentX, currentY, elem.parentElement);
            }
        }

        function setTranslate(xPos, yPos, el) {
            el.style.transform = "translate3d(" + xPos + "px, " + yPos + "px, 0)";
        }
    }

    // -----------------------------------------------------------------------------------
    // Help & Tooltips -------------------------------------------------------------------

    const help = document.getElementById('help');
    const helpBtn = document.getElementById('helpbtn');
    const tooltips = document.getElementsByClassName('tooltip');

    help.addEventListener("click", function() {
        help.style.bottom = '-200px';
        helpBtn.style.display = 'unset';
    });

    helpBtn.addEventListener("click", function() {
        help.style.bottom = '5px';
        helpBtn.style.display = 'none';
    });

    // register all tooltips
    for (let i=0; i<tooltips.length; i++) {
        tooltips[i].parentElement.addEventListener("pointerdown", function() { // mobile
            help.firstChild.innerHTML = tooltips[i].innerHTML;
        }, false);
        tooltips[i].parentElement.addEventListener("pointermove", function() { // desktop
            help.firstChild.innerHTML = tooltips[i].innerHTML;
        }, false);
    }

    if (isMobileDevice()) help.click(); // hide to save space in mobile devices

    // -----------------------------------------------------------------------------------
    // Startup ---------------------------------------------------------------------------

    const STARTUP = `-1,0,-1,#3876C0
                    -1,0,0,#3876C0
                    -1,0,1,#3876C0
                    -1,1,-1,#33D7BE
                    -1,1,0,#33D7BE
                    -1,1,1,#33D7BE
                    -1,2,-1,#B262A0
                    -1,2,0,#B262A0
                    -1,2,1,#B262A0
                    0,0,-1,#3876C0
                    0,0,0,#3876C0
                    0,0,1,#3876C0
                    0,1,-1,#33D7BE
                    0,1,0,#3876C0
                    0,1,1,#33D7BE
                    0,2,-1,#B262A0
                    0,2,0,#33D7BE
                    0,2,1,#B262A0
                    1,0,-1,#3876C0
                    1,0,0,#3876C0
                    1,0,1,#3876C0
                    1,1,-1,#33D7BE
                    1,1,0,#33D7BE
                    1,1,1,#33D7BE
                    1,2,-1,#B262A0
                    1,2,0,#B262A0
                    1,2,1,#B262A0`
    loadProject(STARTUP);

</script>
</html>
